import { createClient } from '@supabase/supabase-js'
import * as fs from 'fs'
import * as path from 'path'
import dotenv from 'dotenv'
dotenv.config({ path: path.resolve(__dirname, '..', '.env.local') })

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!

if (!supabaseUrl || !supabaseKey) {
  console.error('Missing NEXT_PUBLIC_SUPABASE_URL or NEXT_PUBLIC_SUPABASE_ANON_KEY in .env.local')
  process.exit(1)
}

const supabase = createClient(supabaseUrl, supabaseKey)

const ROOT = path.resolve(__dirname, '..')
const TYPES_PATH = path.join(ROOT, 'src', 'types', 'database.ts')
const DOCS_DIR = path.join(ROOT, 'docs')

// ─── Postgres → TypeScript type mapping ────────────────────────────────

const PG_TO_TS: Record<string, string> = {
  // Numeric
  int2: 'number', int4: 'number', int8: 'number',
  float4: 'number', float8: 'number',
  numeric: 'number', decimal: 'number',
  smallint: 'number', integer: 'number', bigint: 'number',
  real: 'number', 'double precision': 'number',
  serial: 'number', bigserial: 'number',
  // String
  text: 'string', varchar: 'string', char: 'string',
  'character varying': 'string', character: 'string',
  name: 'string', citext: 'string',
  uuid: 'string',
  // Boolean
  bool: 'boolean', boolean: 'boolean',
  // Date/Time
  date: 'string', time: 'string',
  timestamp: 'string', timestamptz: 'string',
  'timestamp without time zone': 'string',
  'timestamp with time zone': 'string',
  interval: 'string',
  // JSON
  json: 'Json', jsonb: 'Json',
  // Array (generic fallback)
  ARRAY: 'Json',
}

function pgTypeToTs(dataType: string, udtName: string): string {
  // Array types in pg start with _
  if (udtName.startsWith('_')) {
    const inner = udtName.slice(1)
    const ts = PG_TO_TS[inner] || 'Json'
    return `${ts}[]`
  }
  return PG_TO_TS[dataType] || PG_TO_TS[udtName] || 'Json'
}

// ─── Schema info types ─────────────────────────────────────────────────

interface ColumnInfo {
  column_name: string
  data_type: string
  udt_name: string
  is_nullable: string
  column_default: string | null
  is_primary_key: boolean
  is_unique: boolean
  foreign_key: { foreign_table: string; foreign_column: string } | null
}

interface TableInfo {
  table_name: string
  columns: ColumnInfo[]
}

interface FunctionInfo {
  function_name: string
  arguments: string
  return_type: string
  volatility: string
  security: string
  language: string
  definition: string
}

interface TriggerInfo {
  trigger_name: string
  table_name: string
  event: string
  timing: string
  action_statement: string
  definition: string
}

interface IndexInfo {
  index_name: string
  table_name: string
  is_unique: boolean
  is_primary: boolean
  columns: string[]
  definition: string
}

interface EnumInfo {
  enum_name: string
  values: string[]
}

interface RlsPolicyInfo {
  policy_name: string
  table_name: string
  command: string
  type: string
  using_expression: string | null
  check_expression: string | null
  definition: string
}

interface CronJobInfo {
  jobid: number
  schedule: string
  command: string
  nodename: string
  active: boolean
}

interface SchemaInfo {
  tables: TableInfo[] | null
  functions: FunctionInfo[] | null
  triggers: TriggerInfo[] | null
  indexes: IndexInfo[] | null
  enums: EnumInfo[] | null
  rls_policies: RlsPolicyInfo[] | null
  cron_jobs: CronJobInfo[] | null
}

// ─── Generate database.ts ──────────────────────────────────────────────

function hasDefault(col: ColumnInfo): boolean {
  return col.column_default !== null || col.is_primary_key
}

function generateTypes(schema: SchemaInfo): string {
  const tables = schema.tables || []
  const enums = schema.enums || []

  let out = `// Auto-generated by scripts/update-schema.ts — do not edit manually\n`
  out += `// Generated at: ${new Date().toISOString()}\n\n`

  out += `export type Json =\n`
  out += `  | string\n`
  out += `  | number\n`
  out += `  | boolean\n`
  out += `  | null\n`
  out += `  | { [key: string]: Json | undefined }\n`
  out += `  | Json[]\n\n`

  // Enums
  for (const e of enums) {
    out += `export type ${pascalCase(e.enum_name)} = ${e.values.map(v => `'${v}'`).join(' | ')}\n\n`
  }

  out += `export interface Database {\n`
  out += `  public: {\n`
  out += `    Tables: {\n`

  for (const table of tables) {
    const cols = table.columns || []
    out += `      ${table.table_name}: {\n`

    // Row
    out += `        Row: {\n`
    for (const col of cols) {
      const tsType = pgTypeToTs(col.data_type, col.udt_name)
      const nullable = col.is_nullable === 'YES' ? ` | null` : ''
      out += `          ${col.column_name}: ${tsType}${nullable}\n`
    }
    out += `        }\n`

    // Insert
    out += `        Insert: {\n`
    for (const col of cols) {
      const tsType = pgTypeToTs(col.data_type, col.udt_name)
      const nullable = col.is_nullable === 'YES' ? ` | null` : ''
      const optional = hasDefault(col) || col.is_nullable === 'YES' ? '?' : ''
      out += `          ${col.column_name}${optional}: ${tsType}${nullable}\n`
    }
    out += `        }\n`

    // Update
    out += `        Update: {\n`
    for (const col of cols) {
      const tsType = pgTypeToTs(col.data_type, col.udt_name)
      const nullable = col.is_nullable === 'YES' ? ` | null` : ''
      out += `          ${col.column_name}?: ${tsType}${nullable}\n`
    }
    out += `        }\n`

    // Relationships (required by supabase-js v2.39+)
    out += `        Relationships: []\n`

    out += `      }\n`
  }

  out += `    }\n`
  out += `    Views: {\n`
  out += `      [_ in never]: never\n`
  out += `    }\n`
  out += `    Functions: {\n`
  out += `      [_ in never]: never\n`
  out += `    }\n`
  out += `    Enums: {\n`

  for (const e of enums) {
    out += `      ${e.enum_name}: ${pascalCase(e.enum_name)}\n`
  }

  out += `    }\n`
  out += `  }\n`
  out += `}\n`

  return out
}

// ─── Generate docs ─────────────────────────────────────────────────────

function generateDatabaseMd(schema: SchemaInfo): string {
  const tables = schema.tables || []
  let out = `# Database Schema\n\n`
  out += `> Auto-generated by \`npm run update-schema\` — ${new Date().toISOString()}\n\n`

  for (const table of tables) {
    out += `## ${table.table_name}\n\n`
    out += `| Column | Type | Nullable | Default | PK | FK |\n`
    out += `|--------|------|----------|---------|----|----|`

    for (const col of table.columns || []) {
      const fk = col.foreign_key
        ? `→ ${col.foreign_key.foreign_table}.${col.foreign_key.foreign_column}`
        : ''
      const def = col.column_default ? `\`${col.column_default}\`` : ''
      out += `\n| ${col.column_name} | ${col.udt_name} | ${col.is_nullable} | ${def} | ${col.is_primary_key ? 'YES' : ''} | ${fk} |`
    }
    out += `\n\n`
  }

  return out
}

function generateFunctionListMd(schema: SchemaInfo): string {
  const funcs = schema.functions || []
  let out = `# Database Functions\n\n`
  out += `> Auto-generated by \`npm run update-schema\` — ${new Date().toISOString()}\n\n`

  if (funcs.length === 0) {
    out += `No custom functions found.\n`
    return out
  }

  out += `| Function | Arguments | Returns | Language | Volatility | Security |\n`
  out += `|----------|-----------|---------|----------|------------|----------|`

  for (const f of funcs) {
    out += `\n| ${f.function_name} | ${f.arguments || '—'} | ${f.return_type} | ${f.language} | ${f.volatility} | ${f.security} |`
  }
  out += `\n\n---\n\n`

  for (const f of funcs) {
    out += `### ${f.function_name}\n\n`
    out += `\`\`\`sql\n${f.definition}\n\`\`\`\n\n`
  }

  return out
}

function generateEnumListMd(schema: SchemaInfo): string {
  const enums = schema.enums || []
  let out = `# Database Enums\n\n`
  out += `> Auto-generated by \`npm run update-schema\` — ${new Date().toISOString()}\n\n`

  if (enums.length === 0) {
    out += `No custom enums found.\n`
    return out
  }

  for (const e of enums) {
    out += `## ${e.enum_name}\n\n`
    out += `Values: ${e.values.map(v => `\`${v}\``).join(', ')}\n\n`
  }

  return out
}

function generateTriggerListMd(schema: SchemaInfo): string {
  const triggers = schema.triggers || []
  let out = `# Database Triggers\n\n`
  out += `> Auto-generated by \`npm run update-schema\` — ${new Date().toISOString()}\n\n`

  if (triggers.length === 0) {
    out += `No triggers found.\n`
    return out
  }

  out += `| Trigger | Table | Event | Timing |\n`
  out += `|---------|-------|-------|--------|`

  for (const t of triggers) {
    out += `\n| ${t.trigger_name} | ${t.table_name} | ${t.event} | ${t.timing} |`
  }
  out += `\n\n---\n\n`

  for (const t of triggers) {
    out += `### ${t.trigger_name} (${t.table_name})\n\n`
    out += `\`\`\`sql\n${t.definition}\n\`\`\`\n\n`
  }

  return out
}

function generateIndexListMd(schema: SchemaInfo): string {
  const indexes = schema.indexes || []
  let out = `# Database Indexes\n\n`
  out += `> Auto-generated by \`npm run update-schema\` — ${new Date().toISOString()}\n\n`

  if (indexes.length === 0) {
    out += `No indexes found.\n`
    return out
  }

  out += `| Index | Table | Columns | Unique | Primary |\n`
  out += `|-------|-------|---------|--------|---------|`

  for (const idx of indexes) {
    out += `\n| ${idx.index_name} | ${idx.table_name} | ${idx.columns.join(', ')} | ${idx.is_unique ? 'YES' : ''} | ${idx.is_primary ? 'YES' : ''} |`
  }
  out += `\n\n---\n\n`

  for (const idx of indexes) {
    out += `\`\`\`sql\n${idx.definition};\n\`\`\`\n\n`
  }

  return out
}

function generateRlsPoliciesMd(schema: SchemaInfo): string {
  const policies = schema.rls_policies || []
  let out = `# RLS Policies\n\n`
  out += `> Auto-generated by \`npm run update-schema\` — ${new Date().toISOString()}\n\n`

  if (policies.length === 0) {
    out += `No RLS policies found.\n`
    return out
  }

  // Group by table
  const byTable = new Map<string, RlsPolicyInfo[]>()
  for (const p of policies) {
    const list = byTable.get(p.table_name) || []
    list.push(p)
    byTable.set(p.table_name, list)
  }

  for (const [table, tablePolicies] of byTable) {
    out += `## ${table}\n\n`
    out += `| Policy | Command | Type |\n`
    out += `|--------|---------|------|`

    for (const p of tablePolicies) {
      out += `\n| ${p.policy_name} | ${p.command} | ${p.type} |`
    }
    out += `\n\n`

    for (const p of tablePolicies) {
      out += `\`\`\`sql\n${p.definition}\n\`\`\`\n\n`
    }
  }

  return out
}

function generateCronListMd(schema: SchemaInfo): string {
  const jobs = schema.cron_jobs || []
  let out = `# Cron Jobs\n\n`
  out += `> Auto-generated by \`npm run update-schema\` — ${new Date().toISOString()}\n\n`

  if (jobs.length === 0) {
    out += `No cron jobs found (pg_cron may not be enabled).\n`
    return out
  }

  out += `| ID | Schedule | Command | Node | Active |\n`
  out += `|----|----------|---------|------|--------|`

  for (const j of jobs) {
    out += `\n| ${j.jobid} | \`${j.schedule}\` | \`${j.command}\` | ${j.nodename} | ${j.active ? 'YES' : 'NO'} |`
  }
  out += `\n`

  return out
}

// ─── Helpers ───────────────────────────────────────────────────────────

function pascalCase(str: string): string {
  return str
    .split('_')
    .map(s => s.charAt(0).toUpperCase() + s.slice(1))
    .join('')
}

function writeFile(filePath: string, content: string) {
  fs.mkdirSync(path.dirname(filePath), { recursive: true })
  fs.writeFileSync(filePath, content, 'utf-8')
  console.log(`  ✓ ${path.relative(ROOT, filePath)}`)
}

// ─── Main ──────────────────────────────────────────────────────────────

async function main() {
  console.log('Fetching schema info from Supabase...\n')

  const { data, error } = await supabase.rpc('get_schema_info')

  if (error) {
    console.error('Error calling get_schema_info():', error.message)
    console.error('\nMake sure you have created the function in Supabase.')
    console.error('Run the SQL from: supabase/get_schema_info.sql')
    process.exit(1)
  }

  const schema = data as SchemaInfo

  const tableCount = schema.tables?.length ?? 0
  const funcCount = schema.functions?.length ?? 0
  console.log(`Found: ${tableCount} tables, ${funcCount} functions\n`)

  console.log('Generating files:')

  // Types
  writeFile(TYPES_PATH, generateTypes(schema))

  // Docs
  writeFile(path.join(DOCS_DIR, 'database.md'), generateDatabaseMd(schema))
  writeFile(path.join(DOCS_DIR, 'database_function_list.md'), generateFunctionListMd(schema))
  writeFile(path.join(DOCS_DIR, 'database_enum_list.md'), generateEnumListMd(schema))
  writeFile(path.join(DOCS_DIR, 'database_trigger_list.md'), generateTriggerListMd(schema))
  writeFile(path.join(DOCS_DIR, 'database_index_list.md'), generateIndexListMd(schema))
  writeFile(path.join(DOCS_DIR, 'database_rls_policies.md'), generateRlsPoliciesMd(schema))
  writeFile(path.join(DOCS_DIR, 'database_cron_list.md'), generateCronListMd(schema))

  console.log('\nDone!')
}

main()
